- [전일(12일차) 노션](https://the-fat-cat.notion.site/DAY12-1904c330a3f780cdad71ef0c3dcc9b38)
- [금일(13일차) 노션](https://the-fat-cat.notion.site/DAY13-1914c330a3f7808b8315dbfb792be802)
  <!-- 교안 세부 -->
  - [교안1](https://twhe-fat-cat.notion.site/JavaScript-1-Callback-1914c330a3f7804e9493ff886910989a)
  - [교안2](https://the-fat-cat.notion.site/JavaScript-2-Promise-Async-Await-1914c330a3f780a38e06ea31d7d45969)
  - [교안3](https://the-fat-cat.notion.site/JavaScript-1-JSON-AJAX-1914c330a3f78079917dcf19c28a54bb)
  - [교안4](https://the-fat-cat.notion.site/JavaScript-2-Fetch-Axios-1914c330a3f780dd9ef9d29d0e578078)
  - [교안5](https://the-fat-cat.notion.site/JavaScript-3-OPEN-API-1914c330a3f780ea9f3be4deba25f50e)
  - [교안6](https://the-fat-cat.notion.site/JavaScript-4-Edge-Function-1914c330a3f780be9670eea64f623be2)
  <!-- 실습 -->
  - [실습1](https://codeshare.io/Q8bLoW)
  - [실습2](https://codeshare.io/debnBM)

100 : 20 : 5

1단계 : 서류 100건 넣기 (50건? 20건? 탈락!)
(프로그래머스를 포함한) 3곳 정도 이상의 플랫폼
-> 100건 정도 넣어볼 생각을 함

- 넣었던 회사(동일 계열사)는 웬만하면 3개월 X
- 8~12주 (단기 플젝이나 교육, 성취로 인한 경력 등의 개선)
  => 숫자를 채우기 위해서 조금이라도 걸친다면
  -> 프론트긴한데 어떻게 내가 조금 공부해서 가능하면? 이런것도 넣어봐
  -> 2년차 자리인데 기술폭이 괜찮아보여? 넣어봐...

1. Attitude
2. Skill
3. Knowledge (KSA but ASK)
   -> 이것을 표현하는 법 -> 자소서, 이력서, 포트폴리오

KSA? -> HR. 인사관리.

2? 3? -> Skill? Knowledge?
=> 생성형 AI의 시대로 2,3의 중요성 낮아짐.

그럼 기업이나 다른 것은 무엇을 보는가?
Culture Fit! <- Jod Description
<- Hiring Page

1. 당신이 변할 수 있어? (20%)
   -> 회사가 당신에 맞춰줌.
2. 맞는 기업을 찾을 수 있어? (80%)

소재, 이력, 포트폴리오, 사이트,
기술폭, ..., 네트워크, SNS, 검증...

20~100건의 사례 -> 모수 => 의미있는 sample

1. 경쟁자
2. 검토자(피곤하거나, 누락, ...)
3. 기술적 요인(플랫폼...)
4. 알수없음
   => 온전히 내 탓.
   => 그쯤되면 내가 원인을 내가 알고요
   좀 더 운이 좋으면 물어봐도 좋을 곳이 생겨요
   (왜 떨어졌습니까?)
   그 회사가 아니라도 주변 사람에게 물어봐도 될 정도의
   정신적 여유가 생겨요.

https://drive.google.com/file/d/1wkJFV_LNz72BCMuy7YFwcasIETFw_yQ9/view?usp=sharing

- 슬랙에 업로드 했습니다

확률이란 무엇인가?

- 빈도주의 확률 (해보니까 이렇더라)
  - 귀납, 통계
- 베이지안 확률 (아마도 이러겠지)
  - 추론, 검증, 가설 (연역은 아님...)

정규분포, 펫테일, 왜도, 첨도...?
-> 경향성 -> 전문성 (어느 사람들이 소수인가?)
어떻게 해야 다수가 만족하며,
어떻게 해야 소수가 소외되지 않을 것인가?
=> 베이지안 확률로 실행하며 (교육을 해)
=> 이러면 학생들이 얼마나 참여를 할까?
=> 50%? 20%? 10%?
=> 빈도주의 확률로 확인한다 (평가를 받아)
=> 실제로? 3명? 10명? 20명? 전부?

https://developer.mozilla.org/ko/docs/Glossary/Promise

https://the-fat-cat.notion.site/JavaScript-2-Promise-Async-Await-1914c330a3f780a38e06ea31d7d45969

좋은 툴이나 서비스가 있음 -> 잘 씀 (문제 없음)
근데 망하거나 버벅거리거나 뭐... 조금 그래 (일반인)
-> 근데 나는 뭐야? 어... 나, 개발자(???)
-> 나... 풀스택? 나... 인프라도 좀...? 나... 기획과 AI도 좀?
=> 생각해봄... 김에 아쉬운 것도 좀 보강해...
=> 이거 '탭'으로 해서 움직였으면 좋겠어
=> 그리고 채팅 느낌이었으면 어땠을까? (선택)
=> 좀 아닌 것 같으면 방장인 내가 바로 가리기...?
=> 금지단어, 마스킹 기능 구현 (예: 군대 관련 혹은 폭력적 단어 금지 혹은 가리기)
=> 파일 첨부, 링크 강조... 후후후... 막 노션 느낌? 다이어그램 후후...
(요구사항 정리해... 우선사항 추려... '칸반보드' 만들어.)
=> 비용은? lightsail 쓰고 적당히 react쓰면?? 나쁘지 않을듯...?
백엔드 만들어야하나? 대충 cloudflare로 다 비벼... (전문지식...)
=> 어차피 '내부툴'이야. 버그? 수정해. 여러분이 테스터이자 고객이야
근데? 어떤 고객. 어차피 '코드공유 및 익명성, 안정성'만 보장되면? ㅇㅋ
(굳이 추적기능 오히려 내가 귀찮아...)
=> DAU 40 보장. 근데 나 확실히 유인있음. (돈을 아낌 - 구독료가 아낌)

- 나중에 소스코드 오픈해서 수업에 쓰면 완전 이득 (즐거움+존경심)
- '증명하세요' (증명함)

STT -> Speech To Text => 음성을 인식해서 글자로 만드는 것
TTS -> Text To Speech => 글자를 음성으로 만드는 것
=> 유료 챗 GPT의 경우 음성 채팅이 있죠? TTS/STT <=>.
TTS => 유튜브 같은데서 기계음? 전문성우도 아닌? 더빙용.
음성모델 => 문장을 입력하면 그걸 음성으로 만들어주는...

groq에 보면 STT 모델이 있어요... 그걸 누군가가 캐치를 했지?
그러니까... 거기에 이제 JS와 html을 이용하면...
input을 사용해서... 마이크를 통한 입력 혹은 음성/음악 등의 파일을
업로드 통해 전송 => 무슨 말이야?
=> 그걸 텍스트화할 수 있어? => 무슨 말이야?
잘하면 당신이 만들 수 있어요 회의요약 같은 것. (가장 대표적인 것)
음성 상담 같은 것. 그래도 될 수도 있지...? 아마? 잘 해봐...요?
repo를 푸세요... 물론 내가 해줄수도 있지만... 뭐... 누가 했으니까...

=> 당신의 여행 일기를 소리로 만들어보세요 :)
소리 여행 일기 (사프 뚝딱!)

- bullet point
- nutshell
- cheet sheet

아래는 자바스크립트(ES6 이상) 고급 개발자를 위한 치트 시트입니다. 이 문서는 알고리즘 및 자료구조와 관련된 주제들을 간략한 개요, 코드 예제, 그리고 핵심 포인트로 정리하였습니다.

---

## 1. **언어 기본 및 최신 문법**

- **변수 선언과 스코프**

  - `let`과 `const`를 사용하여 블록 스코프 변수를 선언합니다.
  - `var`는 함수 스코프를 가지며, 호이스팅(hoisting)에 유의합니다.
  - 예제:
    ```javascript
    let a = 10;
    const b = 20;
    var c = 30;
    ```

- **템플릿 리터럴**

  - 문자열 보간 및 다중 행 문자열 작성에 유용.
  - 예제:
    ```javascript
    const name = "John";
    console.log(`Hello, ${name}!`);
    ```

- **화살표 함수 (Arrow Functions)**

  - 짧은 문법 및 this 바인딩 문제 해결.
  - 예제:
    ```javascript
    const add = (x, y) => x + y;
    ```

- **비구조화 할당 (Destructuring)**

  - 배열이나 객체의 값들을 간편하게 추출.
  - 예제:
    ```javascript
    const obj = { x: 1, y: 2 };
    const { x, y } = obj;
    const arr = [1, 2, 3];
    const [first, second] = arr;
    ```

- **전개 구문 (Spread Operator) & 나머지 매개변수 (Rest Parameters)**

  - 배열 및 객체 병합, 복사, 함수 매개변수 처리에 활용.
  - 예제:
    ```javascript
    const arr1 = [1, 2, 3];
    const arr2 = [...arr1, 4, 5];
    const func = (a, b, ...rest) => console.log(a, b, rest);
    func(1, 2, 3, 4, 5);
    ```

- **모듈 시스템 (Modules)**

  - `import`와 `export` 구문으로 코드를 모듈화.
  - 예제:

    ```javascript
    // math.js
    export const add = (a, b) => a + b;

    // main.js
    import { add } from "./math.js";
    console.log(add(2, 3));
    ```

---

## 2. **비동기 처리 및 이벤트 루프**

- **콜백, 프로미스, async/await**

  - 비동기 처리를 위해 콜백 기반 패턴에서 프로미스로, 그리고 async/await로 전환.
  - 예제:

    ```javascript
    // 프로미스 사용 예제
    const fetchData = () => {
      return new Promise((resolve, reject) => {
        setTimeout(() => resolve("data received"), 1000);
      });
    };

    // async/await 사용 예제
    async function getData() {
      try {
        const data = await fetchData();
        console.log(data);
      } catch (error) {
        console.error(error);
      }
    }
    getData();
    ```

- **이벤트 루프 및 작업 큐**
  - 자바스크립트는 단일 스레드 환경에서 이벤트 루프를 통해 비동기 작업을 처리.
  - 마이크로태스크 큐(프로미스 콜백)와 태스크 큐(타이머, I/O 등)의 차이점을 이해.

---

## 3. **자료구조**

- **배열 (Arrays)**

  - 주요 메서드: `map`, `filter`, `reduce`, `forEach`, `find`, `includes`.
  - 예제:
    ```javascript
    const numbers = [1, 2, 3, 4, 5];
    const doubled = numbers.map((n) => n * 2);
    const evens = numbers.filter((n) => n % 2 === 0);
    const sum = numbers.reduce((acc, n) => acc + n, 0);
    ```

- **객체 (Objects) 및 해시맵 (Hash Maps)**

  - 객체는 키-값 쌍 저장, ES6 이후 `Map`과 `Set` 도입.
  - 예제:
    ```javascript
    const person = { name: "Alice", age: 25 };
    const map = new Map();
    map.set("key1", "value1");
    console.log(map.get("key1"));
    ```

- **스택 (Stack)과 큐 (Queue)**

  - **스택**: LIFO(Last In, First Out) 구조
    - 기본 연산: `push`, `pop`, `peek`
    - 예제:
      ```javascript
      class Stack {
        constructor() {
          this.items = [];
        }
        push(element) {
          this.items.push(element);
        }
        pop() {
          return this.items.pop();
        }
        peek() {
          return this.items[this.items.length - 1];
        }
      }
      ```
  - **큐**: FIFO(First In, First Out) 구조
    - 기본 연산: `enqueue`, `dequeue`, `front`
    - 예제:
      ```javascript
      class Queue {
        constructor() {
          this.items = [];
        }
        enqueue(element) {
          this.items.push(element);
        }
        dequeue() {
          return this.items.shift();
        }
        front() {
          return this.items[0];
        }
      }
      ```

- **연결 리스트 (Linked List)**

  - 단일 연결 리스트, 이중 연결 리스트 등 다양한 구현이 가능.
  - 예제 (단일 연결 리스트):

    ```javascript
    class Node {
      constructor(value) {
        this.value = value;
        this.next = null;
      }
    }

    class LinkedList {
      constructor() {
        this.head = null;
      }
      append(value) {
        const newNode = new Node(value);
        if (!this.head) {
          this.head = newNode;
          return;
        }
        let current = this.head;
        while (current.next) {
          current = current.next;
        }
        current.next = newNode;
      }
      // 탐색, 삽입, 삭제 등의 메서드 구현 가능
    }
    ```

- **트리 (Trees)**

  - **이진 탐색 트리 (BST)**

    - 각 노드는 좌측 하위 노드가 작은 값, 우측 하위 노드가 큰 값을 가짐.
    - 예제:

      ```javascript
      class TreeNode {
        constructor(value) {
          this.value = value;
          this.left = null;
          this.right = null;
        }
      }

      class BinarySearchTree {
        constructor() {
          this.root = null;
        }
        insert(value) {
          const newNode = new TreeNode(value);
          if (!this.root) {
            this.root = newNode;
            return;
          }
          let current = this.root;
          while (true) {
            if (value < current.value) {
              if (!current.left) {
                current.left = newNode;
                return;
              }
              current = current.left;
            } else {
              if (!current.right) {
                current.right = newNode;
                return;
              }
              current = current.right;
            }
          }
        }
        // In-order, Pre-order, Post-order 순회 메서드 구현 가능
      }
      ```

- **그래프 (Graphs)**

  - 무방향/유방향, 가중치 그래프 등 다양한 유형이 존재.
  - 인접 리스트 또는 인접 행렬로 표현.
  - 예제 (인접 리스트):
    ```javascript
    class Graph {
      constructor() {
        this.adjList = new Map();
      }
      addVertex(vertex) {
        if (!this.adjList.has(vertex)) {
          this.adjList.set(vertex, []);
        }
      }
      addEdge(v, w) {
        this.adjList.get(v).push(w);
        // 무방향 그래프의 경우:
        // this.adjList.get(w).push(v);
      }
    }
    ```

- **집합 (Set)**
  - 중복되지 않는 값을 저장, ES6에서 내장 `Set` 클래스 제공.
  - 예제:
    ```javascript
    const set = new Set([1, 2, 3, 3, 4]);
    console.log(set.has(3)); // true
    ```

---

## 4. **알고리즘**

- **정렬 알고리즘**

  - **퀵 정렬 (Quick Sort)**
    - 평균 O(n log n) 성능, 피벗 선택 및 분할 정복 전략.
    - 예제:
      ```javascript
      function quickSort(arr) {
        if (arr.length <= 1) return arr;
        const pivot = arr[arr.length - 1];
        const left = [];
        const right = [];
        for (let i = 0; i < arr.length - 1; i++) {
          arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i]);
        }
        return [...quickSort(left), pivot, ...quickSort(right)];
      }
      ```
  - **병합 정렬 (Merge Sort)**
    - 안정적 정렬, 분할 정복으로 O(n log n) 시간 복잡도.
    - 예제:
      ```javascript
      function mergeSort(arr) {
        if (arr.length < 2) return arr;
        const mid = Math.floor(arr.length / 2);
        const left = mergeSort(arr.slice(0, mid));
        const right = mergeSort(arr.slice(mid));
        return merge(left, right);
      }
      function merge(left, right) {
        const result = [];
        while (left.length && right.length) {
          left[0] < right[0]
            ? result.push(left.shift())
            : result.push(right.shift());
        }
        return result.concat(left, right);
      }
      ```

- **검색 알고리즘**

  - **이진 탐색 (Binary Search)**
    - 정렬된 배열에서 O(log n) 시간 복잡도.
    - 예제:
      ```javascript
      function binarySearch(arr, target) {
        let left = 0;
        let right = arr.length - 1;
        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          if (arr[mid] === target) return mid;
          else if (arr[mid] < target) left = mid + 1;
          else right = mid - 1;
        }
        return -1;
      }
      ```

- **그래프 알고리즘**

  - **깊이 우선 탐색 (DFS)**
    - 재귀 또는 스택 사용. 경로 탐색, 사이클 감지 등에 활용.
    - 예제:
      ```javascript
      function dfs(graph, start, visited = new Set()) {
        console.log(start);
        visited.add(start);
        for (const neighbor of graph.get(start) || []) {
          if (!visited.has(neighbor)) {
            dfs(graph, neighbor, visited);
          }
        }
      }
      ```
  - **너비 우선 탐색 (BFS)**
    - 큐를 사용하여 레벨 순서대로 탐색.
    - 예제:
      ```javascript
      function bfs(graph, start) {
        const visited = new Set();
        const queue = [start];
        while (queue.length) {
          const vertex = queue.shift();
          if (!visited.has(vertex)) {
            console.log(vertex);
            visited.add(vertex);
            queue.push(...(graph.get(vertex) || []));
          }
        }
      }
      ```

- **동적 프로그래밍 (Dynamic Programming)**

  - **메모이제이션 (Memoization)과 타뷸레이션 (Tabulation)**
    - 중복 계산을 방지하여 최적화.
    - 예제 (피보나치 수열, 메모이제이션):
      ```javascript
      function fibonacci(n, memo = {}) {
        if (n in memo) return memo[n];
        if (n <= 1) return n;
        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
        return memo[n];
      }
      ```

- **탐욕 알고리즘 (Greedy Algorithms)**

  - 각 단계에서 최적이라고 생각되는 선택을 하는 전략.
  - 예제: 동전 거스름돈 문제(최소 동전 수 구하기)
    ```javascript
    function minCoins(coins, amount) {
      coins.sort((a, b) => b - a);
      let count = 0;
      for (const coin of coins) {
        if (amount >= coin) {
          count += Math.floor(amount / coin);
          amount %= coin;
        }
      }
      return amount === 0 ? count : -1;
    }
    ```

- **백트래킹 (Backtracking)**
  - 재귀를 사용해 가능한 모든 경우를 탐색하는 알고리즘.
  - 예제: N-Queen 문제의 기본 아이디어
    ```javascript
    function solveNQueens(n) {
      const results = [];
      function backtrack(queens = [], xyDiff = new Set(), xySum = new Set()) {
        const row = queens.length;
        if (row === n) {
          results.push(queens);
          return;
        }
        for (let col = 0; col < n; col++) {
          if (
            queens.includes(col) ||
            xyDiff.has(row - col) ||
            xySum.has(row + col)
          )
            continue;
          queens.push(col);
          xyDiff.add(row - col);
          xySum.add(row + col);
          backtrack(queens, xyDiff, xySum);
          queens.pop();
          xyDiff.delete(row - col);
          xySum.delete(row + col);
        }
      }
      backtrack();
      return results;
    }
    ```

---

## 5. **고급 기능 및 패턴**

- **함수형 프로그래밍 (Functional Programming)**

  - **순수 함수, 고차 함수, 불변성**
    - 순수 함수: 같은 입력에 대해 항상 같은 결과 반환, 부작용 없음.
    - 고차 함수: 함수를 인자로 받거나 함수를 반환하는 함수.
    - 불변성: 데이터 변경 대신 새 객체 생성.
  - 예제:
    ```javascript
    const add = (x, y) => x + y;
    const applyOperation = (arr, operation) => arr.map(operation);
    console.log(applyOperation([1, 2, 3], (x) => add(x, 2))); // [3, 4, 5]
    ```

- **클로저 (Closures)**

  - 내부 함수가 외부 함수의 변수에 접근할 수 있는 구조.
  - 예제:
    ```javascript
    function createCounter() {
      let count = 0;
      return function () {
        return ++count;
      };
    }
    const counter = createCounter();
    console.log(counter()); // 1
    console.log(counter()); // 2
    ```

- **프로토타입 및 클래스**

  - **프로토타입 체인**: 객체지향 패턴의 기초, 상속 구현에 사용.
  - ES6 `class` 구문으로 명시적 클래스 정의.
  - 예제:
    ```javascript
    class Animal {
      constructor(name) {
        this.name = name;
      }
      speak() {
        console.log(`${this.name} makes a noise.`);
      }
    }
    class Dog extends Animal {
      speak() {
        console.log(`${this.name} barks.`);
      }
    }
    const d = new Dog("Mitzie");
    d.speak(); // Mitzie barks.
    ```

- **모던 비동기 패턴**

  - **RxJS**: 리액티브 프로그래밍을 위한 라이브러리.
  - **EventEmitter**: Node.js 환경에서 이벤트 기반 아키텍처를 구현.
  - 예제 (Node.js EventEmitter):
    ```javascript
    const EventEmitter = require("events");
    const emitter = new EventEmitter();
    emitter.on("data", (data) => console.log("Received:", data));
    emitter.emit("data", "Hello World!");
    ```

- **메타프로그래밍**
  - **Proxy**와 **Reflect**를 사용해 객체의 기본 동작을 가로채거나 재정의.
  - 예제:
    ```javascript
    const target = { message: "Hello" };
    const handler = {
      get: (obj, prop) => {
        console.log(`Getting property: ${prop}`);
        return Reflect.get(obj, prop);
      },
    };
    const proxy = new Proxy(target, handler);
    console.log(proxy.message); // Getting property: message \n Hello
    ```

---

## 6. **도구 및 최적화**

- **디버깅 및 성능 최적화**

  - **Chrome DevTools**와 **Node.js Inspector**를 활용한 디버깅.
  - 코드 프로파일링, 메모리 릭 분석.
  - **Linting**: ESLint, Prettier를 통한 코드 품질 관리.

- **테스팅 프레임워크**

  - **Jest**, **Mocha**, **Chai** 등을 사용해 단위 테스트 및 통합 테스트 작성.
  - 테스트 커버리지 도구 활용 (Istanbul 등).

- **빌드 도구 및 번들러**

  - **Webpack**, **Rollup**, **Parcel** 등을 사용한 모듈 번들링.
  - ES6 모듈, 코드 스플리팅, 트리 쉐이킹 등 최신 최적화 기법 적용.

- **비동기 에러 핸들링**
  - 전역 에러 핸들러 (`process.on('uncaughtException')`, `window.onerror`)를 사용해 에러 로깅 및 복구.
  - try/catch, promise.catch 등을 적절히 배치.

---

## 7. **최종 요약 (Nutshell)**

- **기본 문법**: 최신 문법(ES6+)을 적극 활용하여 가독성과 유지보수성을 높입니다.
- **비동기 처리**: 프로미스와 async/await를 통해 비동기 코드를 동기적으로 다루며, 이벤트 루프의 작동 원리를 이해합니다.
- **자료구조**: 배열, 객체, 스택, 큐, 연결 리스트, 트리, 그래프 등 다양한 자료구조를 알고 구현하며, 각 자료구조의 시간 복잡도와 공간 복잡도를 이해합니다.
- **알고리즘**: 정렬, 검색, DFS, BFS, 동적 프로그래밍, 탐욕 알고리즘, 백트래킹 등 알고리즘의 기본 원리를 익히고, 실제 문제에 적용하는 연습이 필요합니다.
- **고급 기능**: 함수형 프로그래밍, 클로저, 프로토타입, 모던 비동기 패턴, 메타프로그래밍을 통해 자바스크립트의 유연성을 최대한 활용합니다.
- **도구**: 디버깅, 테스트, 번들링 및 최적화 도구를 사용해 효율적이고 유지보수 가능한 코드를 작성합니다.

이 치트 시트는 고급 자바스크립트 개발자가 기본 문법에서부터 자료구조와 알고리즘, 그리고 최신 개발 패턴까지 통합적으로 이해하고 적용하는 데 도움을 주기 위한 가이드입니다. 각 섹션에서 제시한 예제와 개념들을 실습하면서, 실제 프로젝트에서 어떻게 응용할 수 있는지 고민해 보시기 바랍니다.

---

## 참고 자료

- MDN Web Docs: https://developer.mozilla.org
- JavaScript Info: https://javascript.info
- Eloquent JavaScript: https://eloquentjavascript.net
- Node.js 공식 문서: https://nodejs.org/en/docs

이상으로 고급 자바스크립트 치트 시트를 마칩니다.

only commit & merge
not rebase, not amend, not revert, sometime reset... (just staging)

# just git push --force-with-lease # readme issue

정보 : 150% T도 울긴 함 but 운다는 것 또다른 정보. (위급함, 시급성, 절박함)

[Gamma](https://gamma.app/ko)
[Figma: The Collaborative Interface Design Tool](https://www.figma.com/)

gamma ai를 통해서 수강생들이 취업에 도움이 될 수 있도록 최신 개발자 트렌드를 배우는 방법에 대한 프레젠테이션을 만들거야 영문으로 프롬프트를 작성하되 한글로 결과물이 나올 수 있도록 프롬프트를 작성해줘.
너무 길지 않게. 10개 슬라이드. 프리티어야.
여전히 길어. 10줄 이내로.

10개의 슬라이드. 10줄 이내. 영어로 된 gamma ai를 위한 프레젠테이션 생성용 프롬프트. 여행 프런트엔드 웹앱 프로젝트. 백엔드 개발자로 취업을 위한 포트폴리오이나 본격 프로젝트에 앞서 html, css, js만으로 개발. 최신 기술을 반영하고 인간의 핵심적 욕망과 상업성을 드러내지만 기술적인 유능성 또한 놓치지 않는 주제로 선정.
너무 길어 좀 더 압축.
여전히 길어 절반으로 압축.

i18n -> TIL

https://the-fat-cat.notion.site/DAY13-1914c330a3f7808b8315dbfb792be802

1. back to files로 못나가서 계속 figma로 새로 접속함 ???
2. frame 못만들어서 계속 ai로 매번 새로 디자인 해야함 ???
   => 나머지는 얼추함. 왜? gui랑 자료 있어서 가능한데... 이건 아무도 굳이 설명 안함
   => 동영상도 없어 왜? 어... 굳이 안찍어... 아무도... 굳이... 안찍어...? 왜???
3. 내장 asset(library)도 꽤나 괜찮은데 (plugin면 괜찮아~)

- 어디에선가 자꾸 그래픽캡쳐나 도형그려서 와이어프레임하고 있었음(;;;;)
  4번부터는... 디발자임(솔직히...) -> 직무간 융합임. 뭔가... 돌이킬 수 없음...
  당신에게 개발 외적 일이 주어지기 시작합니다.
- 취업의 확률이 좀 늘어나지만... 삶이 행복한지는 잘 모르겠습니다(

4. 외부에서 템플릿, 아이콘, 디자인시스템, 플러그인 찾아서 적용해보기

- ui kits
- html, css, js, tailwind, bootstrap, react, code...
- color
- gpt, llm
- size, alignment, ...
- i18n, ...
